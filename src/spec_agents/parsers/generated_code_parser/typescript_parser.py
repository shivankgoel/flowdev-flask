import re
from typing import List, Tuple
from .base_parser import BaseCodeParser

class TypeScriptCodeParser(BaseCodeParser):
    """Parser for TypeScript code generated by LLM."""
    
    def __init__(self):
        super().__init__()
        self.import_pattern = re.compile(r'^import\s+([^;]+);$|^import\s+{\s*([^}]+)\s*}\s+from\s+[\'"]([^\'"]+)[\'"];$', re.MULTILINE)
        self.interface_pattern = re.compile(r'^interface\s+(\w+)\s*{', re.MULTILINE)
        self.class_pattern = re.compile(r'^export\s+class\s+(\w+)\s*(?:implements\s+(\w+))?\s*{', re.MULTILINE)
        self.type_pattern = re.compile(r':\s*([^=;]+)(?:;|$)')

    def _extract_code_parts(self, code: str) -> Tuple[List[str], str]:
        """
        Extract imports and main code from TypeScript code.
        
        Args:
            code: The complete TypeScript code string
            
        Returns:
            Tuple[List[str], str]: List of imports and main code
        """
        # Extract imports
        imports = self._extract_imports(code)
        
        # Validate imports
        self._validate_imports(imports)
        
        # Extract main code (everything after imports)
        main_code = self._extract_main_code(code)
        
        # Validate class and interface structure
        self._validate_structure(main_code)
        
        return imports, main_code

    def _extract_imports(self, code: str) -> List[str]:
        """
        Extract TypeScript imports.
        
        Args:
            code: Complete code string
            
        Returns:
            List[str]: List of import statements
        """
        imports = []
        for match in self.import_pattern.finditer(code):
            if match.group(1):  # regular import
                imports.append(match.group(1).strip())
            elif match.group(2) and match.group(3):  # named import
                imports.append(f"import {{ {match.group(2).strip()} }} from '{match.group(3).strip()}'")
        return imports

    def _validate_imports(self, imports: List[str]) -> None:
        """
        Validate TypeScript imports.
        
        Args:
            imports: List of import statements
            
        Raises:
            ValueError: If imports are invalid
        """
        for imp in imports:
            if not re.match(r'^[a-zA-Z][a-zA-Z0-9_.]*$', imp.split()[1]):
                raise ValueError(f"Invalid import statement: {imp}")

    def _extract_main_code(self, code: str) -> str:
        """
        Extract main code after imports.
        
        Args:
            code: Complete code string
            
        Returns:
            str: Main code without imports
        """
        # Find the last import statement
        last_import = 0
        for match in self.import_pattern.finditer(code):
            last_import = match.end()
        
        # Return everything after the last import
        return code[last_import:].strip()

    def _validate_structure(self, code: str) -> None:
        """
        Validate TypeScript class and interface structure.
        
        Args:
            code: Main code string
            
        Raises:
            ValueError: If structure is invalid
        """
        # Check for class or interface declaration
        class_match = self.class_pattern.search(code)
        interface_match = self.interface_pattern.search(code)
        
        if not class_match and not interface_match:
            raise ValueError("No class or interface declaration found")
        
        # Check for matching braces
        brace_count = 0
        for char in code:
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count < 0:
                    raise ValueError("Unmatched closing brace")
        
        if brace_count != 0:
            raise ValueError("Unmatched opening brace")
        
        # Check for proper type annotations
        lines = code.split('\n')
        for i, line in enumerate(lines):
            if ':' in line and not self.type_pattern.search(line):
                raise ValueError(f"Invalid type annotation at line {i+1}") 