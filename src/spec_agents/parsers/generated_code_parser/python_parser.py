import re
from typing import List, Tuple
from .base_parser import BaseCodeParser

class PythonCodeParser(BaseCodeParser):
    """Parser for Python code generated by LLM."""
    
    def __init__(self):
        super().__init__()
        self.import_pattern = re.compile(r'^import\s+([^#\n]+)$|^from\s+([^#\n]+)\s+import\s+([^#\n]+)$', re.MULTILINE)
        self.class_pattern = re.compile(r'^class\s+(\w+)\s*\(?([^)]*)\)?\s*:', re.MULTILINE)
        self.type_hint_pattern = re.compile(r':\s*([^=]+)\s*=\s*')

    def _extract_code_parts(self, code: str) -> Tuple[List[str], str]:
        """
        Extract imports and main code from Python code.
        
        Args:
            code: The complete Python code string
            
        Returns:
            Tuple[List[str], str]: List of imports and main code
        """
        # Extract imports
        imports = self._extract_imports(code)
        
        # Validate imports
        self._validate_imports(imports)
        
        # Extract main code (everything after imports)
        main_code = self._extract_main_code(code)
        
        # Validate class structure
        self._validate_class_structure(main_code)
        
        return imports, main_code

    def _extract_imports(self, code: str) -> List[str]:
        """
        Extract Python imports.
        
        Args:
            code: Complete code string
            
        Returns:
            List[str]: List of import statements
        """
        imports = []
        for match in self.import_pattern.finditer(code):
            if match.group(1):  # import statement
                imports.append(match.group(1).strip())
            elif match.group(2) and match.group(3):  # from ... import statement
                imports.append(f"from {match.group(2).strip()} import {match.group(3).strip()}")
        return imports

    def _validate_imports(self, imports: List[str]) -> None:
        """
        Validate Python imports.
        
        Args:
            imports: List of import statements
            
        Raises:
            ValueError: If imports are invalid
        """
        for imp in imports:
            if not re.match(r'^[a-zA-Z][a-zA-Z0-9_.]*$', imp.split()[0]):
                raise ValueError(f"Invalid import statement: {imp}")

    def _extract_main_code(self, code: str) -> str:
        """
        Extract main code after imports.
        
        Args:
            code: Complete code string
            
        Returns:
            str: Main code without imports
        """
        # Find the last import statement
        last_import = 0
        for match in self.import_pattern.finditer(code):
            last_import = match.end()
        
        # Return everything after the last import
        return code[last_import:].strip()

    def _validate_class_structure(self, code: str) -> None:
        """
        Validate Python class structure.
        
        Args:
            code: Main code string
            
        Raises:
            ValueError: If class structure is invalid
        """
        # Check for class declaration
        class_match = self.class_pattern.search(code)
        if not class_match:
            raise ValueError("No class declaration found")
        
        # Check for proper indentation
        lines = code.split('\n')
        for i, line in enumerate(lines):
            if line.strip() and not line.startswith(' '):
                raise ValueError(f"Invalid indentation at line {i+1}") 